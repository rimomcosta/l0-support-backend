diff --git a/src/adapters/magentoCloud.js b/src/adapters/magentoCloud.js
index 2be5082..dbbffaf 100644
--- a/src/adapters/magentoCloud.js
+++ b/src/adapters/magentoCloud.js
@@ -1,56 +1,107 @@
 // src/adapters/magentoCloud.js
-import { access, constants } from 'fs/promises';
+import { access, constants, mkdir } from 'fs/promises';
 import { promisify } from 'util';
 import { exec } from 'child_process';
 import { logger } from '../services/logger.js';
 import { paths } from '../config/paths.js';
+import path from 'path';
+import os from 'os';
 
 const execAsync = promisify(exec);
 
 class MagentoCloudAdapter {
     constructor() {
         this.executablePath = paths.resources.magentoCloud;
+        this.baseHomeDir = path.join(os.tmpdir(), 'magento-cloud'); // Base directory for all users
     }
 
+    /**
+     * Validates that the Magento Cloud executable exists and is executable.
+     */
     async validateExecutable() {
         try {
             await access(this.executablePath, constants.X_OK);
-            logger.debug('Magento cloud executable validated');
+            logger.debug('Magento Cloud executable validated');
         } catch (err) {
-            logger.error('Magento cloud executable validation failed:', {
+            logger.error('Magento Cloud executable validation failed:', {
                 error: err.message,
                 path: this.executablePath,
                 timestamp: new Date().toISOString()
             });
-            throw new Error('Magento cloud executable not found or not executable');
+            throw new Error('Magento Cloud executable not found or not executable');
         }
     }
 
-    async executeCommand(command, apiToken) {
-        console.log('apiToken in MagentoCloudAdapter:executeCommand=====>', apiToken);
+    /**
+     * Generates a unique Magento Cloud home directory path based on userId.
+     * @param {string} userId - The unique identifier for the user
+     * @returns {string} - The path to the user's Magento Cloud home directory
+     */
+    generateHomeDir(userId) {
+        // Sanitize userId to prevent directory traversal or injection
+        const sanitizedUserId = userId.replace(/[^a-zA-Z0-9-_]/g, '');
+        return path.join(this.baseHomeDir, `user-${sanitizedUserId}`);
+    }
+
+    /**
+     * Ensures that the provided home directory exists.
+     * @param {string} homeDir - The directory to be used as MAGENTO_CLOUD_HOME
+     */
+    async ensureHomeDir(homeDir) {
+        try {
+            await mkdir(homeDir, { recursive: true, mode: 0o700 });
+            logger.debug(`Ensured Magento Cloud home directory exists: ${homeDir}`);
+        } catch (err) {
+            logger.error('Failed to create Magento Cloud home directory:', {
+                error: err.message,
+                homeDir,
+                timestamp: new Date().toISOString()
+            });
+            throw new Error('Failed to create Magento Cloud home directory');
+        }
+    }
+
+    /**
+     * Executes a Magento Cloud CLI command with dynamic environment variables.
+     * @param {string} command - The command to execute
+     * @param {string} apiToken - The API token for authentication
+     * @param {string} userId - The unique identifier for the user
+     * @returns {Object} - The stdout and stderr from the command
+     */
+    async executeCommand(command, apiToken, userId) {
+        console.log('userId in magentoCloudAdapter:executeCommand=====>', userId);
         if (!apiToken) {
             throw new Error("API token is required for Magento Cloud CLI commands.");
         }
-    
+
+        if (!userId) {
+            throw new Error("User ID is required to generate Magento Cloud home directory.");
+        }
+
+        // Generate and ensure the home directory exists
+        const homeDir = this.generateHomeDir(userId);
+        await this.ensureHomeDir(homeDir);
+
         try {
             const { stdout, stderr } = await execAsync(`${this.executablePath} ${command}`, {
                 env: {
                     ...process.env,
-                    // PATH: `/usr/local/bin:/usr/bin:${process.env.PATH}`, // To allow using PHP from PATH
-                    MAGENTO_CLOUD_CLI_TOKEN: apiToken
+                    PATH: `/usr/local/bin:/usr/bin:${process.env.PATH}`, // To allow using PHP from PATH
+                    MAGENTO_CLOUD_CLI_TOKEN: apiToken,
+                    MAGENTO_CLOUD_HOME: homeDir
                 },
                 maxBuffer: 1024 * 1024 * 10 // 10MB buffer
             });
             return { stdout, stderr };
         } catch (error) {
             if (command.startsWith('tunnel:info') && error.message.includes('No tunnels found')) {
-                logger.info('Magento cloud command execution (tunnel:info) returned no tunnel info (expected when tunnel is closed).', {
+                logger.info('Magento Cloud command execution (tunnel:info) returned no tunnel info (expected when tunnel is closed).', {
                     command,
                     timestamp: new Date().toISOString()
                 });
                 return { stdout: '', stderr: error.message };
             } else {
-                logger.error('Magento cloud command execution failed:', {
+                logger.error('Magento Cloud command execution failed:', {
                     error: error.message,
                     command,
                     timestamp: new Date().toISOString()
@@ -60,23 +111,46 @@ class MagentoCloudAdapter {
         }
     }
 
-    executeCommandStream(command, apiToken) {
-        console.log('apiToken in MagentoCloudAdapter:executeCommandStream=====>', apiToken);
+    /**
+     * Executes a Magento Cloud CLI command and streams its output.
+     * @param {string} command - The command to execute
+     * @param {string} apiToken - The API token for authentication
+     * @param {string} userId - The unique identifier for the user
+     * @returns {Object} - The child process
+     */
+    executeCommandStream(command, apiToken, userId) {
+        console.log('userId in magentoCloudAdapter:executeCommandStream=====>', userId);
         if (!apiToken) {
             throw new Error("API token is required for Magento Cloud CLI commands.");
         }
-    
+
+        if (!userId) {
+            throw new Error("User ID is required to generate Magento Cloud home directory.");
+        }
+
+        // Generate and ensure the home directory exists
+        const homeDir = this.generateHomeDir(userId);
+        this.ensureHomeDir(homeDir).catch(err => {
+            logger.error('Failed to ensure Magento Cloud home directory:', {
+                error: err.message,
+                homeDir,
+                timestamp: new Date().toISOString()
+            });
+            throw err;
+        });
+
         const tunnelProcess = exec(`${this.executablePath} ${command}`, {
             env: {
                 ...process.env,
                 PATH: `/usr/local/bin:/usr/bin:${process.env.PATH}`, // To allow using PHP from PATH
-                MAGENTO_CLOUD_CLI_TOKEN: apiToken
+                MAGENTO_CLOUD_CLI_TOKEN: apiToken,
+                MAGENTO_CLOUD_HOME: homeDir
             },
             maxBuffer: 1024 * 1024 * 10 // 10MB buffer
         });
-    
+
         return { tunnelProcess };
     }
 }
 
-export default MagentoCloudAdapter;
\ No newline at end of file
+export default MagentoCloudAdapter;
diff --git a/src/api/app/commands.js b/src/api/app/commands.js
index 8c289e1..ca132ca 100644
--- a/src/api/app/commands.js
+++ b/src/api/app/commands.js
@@ -19,66 +19,71 @@ const commandService = new CommandService();
 const SERVICE_HANDLERS = {
     ssh: {
         handler: sshCommands.runCommands,
-        preparePayload: (commands, projectId, environment, apiToken) => ({
+        preparePayload: (commands, projectId, environment, apiToken, userId) => ({
             commands: commands.map(cmd => ({
                 id: cmd.id,
                 title: cmd.title,
                 command: cmd.command,
                 executeOnAllNodes: Boolean(cmd.execute_on_all_nodes),
-                apiToken: apiToken
+                apiToken: apiToken,
+                userId: userId
             }))
         })
     },
     rabbitmq: {
         handler: rabbitmqCommands.runCommands,
-        preparePayload: (commands, projectId, environment, apiToken) => ({
+        preparePayload: (commands, projectId, environment, apiToken, userId) => ({
             commands: commands.map(cmd => ({
                 id: cmd.id,
                 title: cmd.title,
                 command: cmd.command, // Use "command" for RabbitMQ
-                apiToken: apiToken
+                apiToken: apiToken,
+                userId: userId
             }))
         })
     },
     bash: {
         handler: bashCommands.runCommands,
-        preparePayload: (commands, projectId, environment, apiToken) => ({
+        preparePayload: (commands, projectId, environment, apiToken, userId) => ({
             commands: commands.map(cmd => ({
                 id: cmd.id,
                 title: cmd.title,
                 command: cmd.command,
-                apiToken: apiToken
+                apiToken: apiToken,
+                userId: userId
             }))
         })
     },
     sql: {
         handler: sqlCommands.runQueries,
-        preparePayload: (commands, projectId, environment, apiToken, tunnelInfo) => ({
+        preparePayload: (commands, projectId, environment, apiToken, tunnelInfo, userId) => ({
             queries: commands.map(cmd => ({
                 id: cmd.id,
                 title: cmd.title,
                 query: cmd.command,
                 executeOnAllNodes: Boolean(cmd.execute_on_all_nodes),
                 apiToken: apiToken,
-                tunnelInfo: tunnelInfo
+                tunnelInfo: tunnelInfo,
+                userId: userId
             }))
         })
     },
     redis: {
         handler: redisCommands.runQueries,
-        preparePayload: (commands, projectId, environment, apiToken, tunnelInfo) => ({
+        preparePayload: (commands, projectId, environment, apiToken, tunnelInfo, userId) => ({
             queries: commands.map(cmd => ({
                 id: cmd.id,
                 title: cmd.title,
                 query: cmd.command,
                 apiToken: apiToken,
-                tunnelInfo: tunnelInfo
+                tunnelInfo: tunnelInfo,
+                userId: userId
             }))
         })
     },
     opensearch: {
         handler: openSearchCommands.runQueries,
-        preparePayload: (commands, projectId, environment, apiToken, tunnelInfo) => ({
+        preparePayload: (commands, projectId, environment, apiToken, tunnelInfo, userId) => ({
             queries: commands.map(cmd => {
                 const config = typeof cmd.command === 'string'
                     ? JSON.parse(cmd.command)
@@ -88,14 +93,15 @@ const SERVICE_HANDLERS = {
                     title: cmd.title,
                     command: config,
                     apiToken: apiToken,
-                    tunnelInfo: tunnelInfo
+                    tunnelInfo: tunnelInfo,
+                    userId: userId
                 };
             })
         })
     },
     magento_cloud: {
         handler: magentoCloudDirectAccess.executeCommands,
-        preparePayload: (commands, projectId, environment, apiToken) => ({
+        preparePayload: (commands, projectId, environment, apiToken, userId) => ({
             commands: commands.map(cmd => {
                 let command = cmd.command;
                 command = command
@@ -109,7 +115,8 @@ const SERVICE_HANDLERS = {
                     id: cmd.id,
                     title: cmd.title,
                     command: command,
-                    apiToken: apiToken
+                    apiToken: apiToken,
+                    userId: userId
                 };
             })
         })
@@ -127,13 +134,12 @@ async function executeServiceCommands(serviceType, commands, projectId, environm
 
     const { handler, preparePayload } = serviceHandler;
 
-    // Group commands that require tunnels
+    // Determine if the service requires a tunnel
     let tunnelNeeded = ['redis', 'sql', 'opensearch'].includes(serviceType);
     let tunnelInfo = null;
 
     if (tunnelNeeded) {
         try {
-            // Ensure the tunnel is open before proceeding
             tunnelInfo = await tunnelManager.openTunnel(projectId, environment, apiToken, userId);
             if (!tunnelInfo) {
                 throw new Error('Tunnel information is unavailable after opening.');
@@ -149,12 +155,26 @@ async function executeServiceCommands(serviceType, commands, projectId, environm
         }
     }
 
+    // Prepare the payload with appropriate arguments
+    let payload;
+    if (tunnelNeeded) {
+        payload = preparePayload(commands, projectId, environment, apiToken, tunnelInfo, userId);
+    } else {
+        payload = preparePayload(commands, projectId, environment, apiToken, userId);
+    }
+
+    logger.debug(`Executing commands for userId: ${userId}`, {
+        serviceType,
+        projectId,
+        environment
+    });
+
     const request = {
         params: {
             projectId,
             environment
         },
-        body: preparePayload(commands, projectId, environment, apiToken, tunnelInfo),
+        body: payload,
         session: {
             user: {
                 id: userId
@@ -188,6 +208,8 @@ async function executeServiceCommands(serviceType, commands, projectId, environm
     }
 }
 
+
+
 // Detect if a command should use bash service
 function shouldUseBashService(command) {
     // List of bash operators and special characters that indicate bash usage
diff --git a/src/api/app/environment.js b/src/api/app/environment.js
index 1a1e461..7c8d2d9 100644
--- a/src/api/app/environment.js
+++ b/src/api/app/environment.js
@@ -3,12 +3,12 @@ import { logger } from '../../services/logger.js';
 import MagentoCloudAdapter from '../../adapters/magentoCloud.js';
 // import { ApiTokenService } from '../../services/apiTokenService.js'; // Import ApiTokenService
 
-async function listEnvironments(projectId, apiToken) {
+async function listEnvironments(projectId, apiToken, userId) {
     console.log('apiToken in environment:listEnvironments=====>', apiToken);
     const magentoCloud = new MagentoCloudAdapter();
     await magentoCloud.validateExecutable();
 
-    const { stdout, stderr } = await magentoCloud.executeCommand(`environment:list -p ${projectId}`, apiToken); // Pass apiToken
+    const { stdout, stderr } = await magentoCloud.executeCommand(`environment:list -p ${projectId}`, apiToken, userId); // Pass apiToken
     const output = stdout + stderr;
 
     const lines = output.split('\n').filter(line => line.trim());
@@ -49,7 +49,7 @@ export async function getEnvironments(req, res) {
             return res.status(401).json({ error: 'API token not found for user' });
         }
 
-        const environments = await listEnvironments(projectId, apiToken);
+        const environments = await listEnvironments(projectId, apiToken, userId);
 
         if (environments.length === 0) {
             logger.warn('No active environments found', {
diff --git a/src/api/app/magentoCloudDirectAccess.js b/src/api/app/magentoCloudDirectAccess.js
index 7413ff6..20dc07e 100644
--- a/src/api/app/magentoCloudDirectAccess.js
+++ b/src/api/app/magentoCloudDirectAccess.js
@@ -1,8 +1,12 @@
 // src/api/app/magentoCloudDirectAccess.js
 import { logger } from '../../services/logger.js';
 import MagentoCloudAdapter from '../../adapters/magentoCloud.js';
-// import { ApiTokenService } from '../../services/apiTokenService.js';
 
+/**
+ * Normalizes project flags in the command.
+ * @param {string} command - The original command
+ * @returns {string} - The normalized command
+ */
 function normalizeProjectFlag(command) {
     const parts = command.split('|');
     const magentoCommand = parts[0];
@@ -18,10 +22,21 @@ function normalizeProjectFlag(command) {
     return normalized;
 }
 
+/**
+ * Escapes quotes in the command for shell execution.
+ * @param {string} command - The command to escape
+ * @returns {string} - The escaped command
+ */
 function escapeQuotesForShell(command) {
     return command.replace(/"/g, '\\"');
 }
 
+/**
+ * Replaces placeholders in the command with actual values.
+ * @param {string} command - The command with placeholders
+ * @param {Object} context - The context containing actual values
+ * @returns {string} - The processed command
+ */
 function replacePlaceholders(command, context) {
     let processedCommand = normalizeProjectFlag(command);
     processedCommand = processedCommand.replace(/^magento-cloud\s+/, '');
@@ -59,23 +74,26 @@ function replacePlaceholders(command, context) {
     return processedCommand.trim();
 }
 
-export async function executeCommand(magentoCloud, command, context, apiToken) {
-    console.log('apiToken in magentoCloudDirectAccess:executeCommand=====>', apiToken);
+/**
+ * Executes a single Magento Cloud CLI command.
+ * @param {MagentoCloudAdapter} magentoCloud - The MagentoCloudAdapter instance
+ * @param {string} command - The command to execute
+ * @param {Object} context - The context containing projectId, environment, and instance
+ * @param {string} apiToken - The API token for authentication
+ * @param {string} userId - The unique identifier for the user
+ * @returns {Object} - The result of the command execution
+ */
+export async function executeCommand(magentoCloud, command, context, apiToken, userId) {
+    logger.debug('Executing Magento Cloud command:', { command, context, userId });
     try {
         let processedCommand = replacePlaceholders(command, context);
         processedCommand = escapeQuotesForShell(processedCommand);
 
-        logger.debug('Executing magento-cloud command:', {
-            originalCommand: command,
-            processedCommand,
-            context
-        });
-
         if (!processedCommand) {
             throw new Error('Invalid command after processing placeholders');
         }
 
-        const { stdout, stderr } = await magentoCloud.executeCommand(processedCommand, apiToken);
+        const { stdout, stderr } = await magentoCloud.executeCommand(processedCommand, apiToken, userId);
 
         return {
             output: stdout || null,
@@ -97,6 +115,11 @@ export async function executeCommand(magentoCloud, command, context, apiToken) {
     }
 }
 
+/**
+ * Handles the execution of multiple Magento Cloud CLI commands.
+ * @param {Object} req - The Express request object
+ * @param {Object} res - The Express response object
+ */
 export async function executeCommands(req, res) {
     const { projectId, environment, instance } = req.params;
     const { commands } = req.body;
@@ -130,7 +153,8 @@ export async function executeCommands(req, res) {
                 magentoCloud, 
                 cmd.command,
                 context,
-                apiToken // Pass apiToken to executeCommand
+                apiToken, // Pass apiToken to executeCommand
+                userId    // Pass userId to executeCommand
             );
             
             return {
@@ -173,3 +197,86 @@ export async function executeCommands(req, res) {
         });
     }
 }
+
+/**
+ * Handles the execution of SSH commands.
+ * @param {Object} req - The Express request object
+ * @param {Object} res - The Express response object
+ */
+export async function executeSSHCommand(req, res) {
+    const { projectId, environment } = req.params;
+    const { command } = req.body;
+    const userId = req.session.user.id;
+    const apiToken = req.session.decryptedApiToken;
+
+    if (!command) {
+        return res.status(400).json({
+            error: 'Invalid request format',
+            details: 'Command must be provided'
+        });
+    }
+
+    if (!apiToken) {
+        return res.status(401).json({ error: 'API token not found for user' });
+    }
+
+    try {
+        const magentoCloud = new MagentoCloudAdapter();
+        await magentoCloud.validateExecutable();
+
+        const context = { 
+            projectId, 
+            environment: environment || null,
+            instance: null // SSH might not need instance
+        };
+
+        // Process and sanitize the command
+        let processedCommand = replacePlaceholders(command, context);
+        processedCommand = escapeQuotesForShell(processedCommand);
+
+        if (!processedCommand) {
+            throw new Error('Invalid command after processing placeholders');
+        }
+
+        // Execute the SSH command as a stream
+        const { tunnelProcess } = magentoCloud.executeCommandStream(processedCommand, apiToken, userId);
+        logger.debug('Executing Magento Cloud command for userId:magentoCloudDirectAccess:executeCommandStream',userId);
+        // Set headers for streaming
+        res.setHeader('Content-Type', 'text/plain');
+        res.setHeader('Transfer-Encoding', 'chunked');
+
+        // Stream stdout to the client
+        tunnelProcess.stdout.on('data', (data) => {
+            res.write(data);
+        });
+
+        // Stream stderr to the client
+        tunnelProcess.stderr.on('data', (data) => {
+            res.write(data);
+        });
+
+        // Handle process exit
+        tunnelProcess.on('close', (code) => {
+            res.end(`\nProcess exited with code ${code}`);
+        });
+
+        // Handle errors
+        tunnelProcess.on('error', (err) => {
+            logger.error('SSH process error:', { error: err.message, userId });
+            res.status(500).end('SSH process encountered an error.');
+        });
+
+    } catch (error) {
+        logger.error('SSH command execution failed:', {
+            error: error.message,
+            projectId,
+            environment,
+            userId
+        });
+
+        res.status(500).json({
+            error: 'SSH command execution failed',
+            details: process.env.NODE_ENV === 'development' ? error.message : undefined
+        });
+    }
+}
diff --git a/src/api/app/nodes.js b/src/api/app/nodes.js
index 4fab3be..b6ece22 100644
--- a/src/api/app/nodes.js
+++ b/src/api/app/nodes.js
@@ -11,13 +11,14 @@ import { ApiTokenService } from '../../services/apiTokenService.js'; // Import A
  * @param {string} apiToken - The user's API token
  * @returns {Promise<Array<Object>>} Array of node objects with id, sshUrl, and status
  */
-export async function execute(projectId, environment, apiToken) {
+export async function execute(projectId, environment, apiToken, userId) {
     const magentoCloud = new MagentoCloudAdapter();
     await magentoCloud.validateExecutable();
 
     const { stdout } = await magentoCloud.executeCommand(
         `ssh -p ${projectId} -e ${environment} --all`,
-        apiToken // Pass apiToken
+        apiToken,
+        userId
     );
 
     return stdout.split('\n')
@@ -38,6 +39,7 @@ export async function execute(projectId, environment, apiToken) {
 export async function getNodes(req, res) {
     const { projectId, environment } = req.params;
     const userId = req.session.user.id; // Get userId
+    const apiToken = req.session.decryptedApiToken;
 
     try {
         logger.info('Fetching nodes', {
@@ -47,12 +49,11 @@ export async function getNodes(req, res) {
             timestamp: new Date().toISOString()
         });
 
-        const apiToken = await ApiTokenService.getApiToken(userId); // Get API token
         if (!apiToken) {
             return res.status(401).json({ error: 'API token not found for user' });
         }
 
-        const nodes = await execute(projectId, environment, apiToken); // Pass apiToken
+        const nodes = await execute(projectId, environment, apiToken, userId); // Pass apiToken
         res.json({ nodes });
     } catch (error) {
         logger.error('Failed to fetch nodes', {
diff --git a/src/api/app/rabbitmqCommands.js b/src/api/app/rabbitmqCommands.js
index aecb43c..c2860fc 100644
--- a/src/api/app/rabbitmqCommands.js
+++ b/src/api/app/rabbitmqCommands.js
@@ -21,8 +21,8 @@ export async function runCommands(req, res) {
         }
 
         // Initialize RabbitMQAdminService with projectId, environment, and apiToken
-        const rabbitmqService = new RabbitMQAdminService(projectId, environment, apiToken);
-
+        const rabbitmqService = new RabbitMQAdminService(projectId, environment, apiToken, userId);
+console.log('userId in rabbitmqCommands:runCommands=====>', userId);
         const results = [];
 
         for (const command of commands) {
diff --git a/src/api/app/sqlCommands.js b/src/api/app/sqlCommands.js
index 25c3fee..bc07fed 100644
--- a/src/api/app/sqlCommands.js
+++ b/src/api/app/sqlCommands.js
@@ -87,7 +87,7 @@ ${bundleQueries(queries)} | mysql -u"$username" -p"$password" -D"$database" -h"$
 }
 
 // Execute queries on a specific node via SSH
-async function executeQueriesOnNode(magentoCloud, projectId, environment, nodeId, queries, apiToken) {
+async function executeQueriesOnNode(magentoCloud, projectId, environment, nodeId, queries, apiToken, userId) {
     try {
         const mysqlCommand = createMySQLCommand(queries);
         const sshCommand = `ssh -p ${projectId} -e ${environment} --instance ${nodeId} ${mysqlCommand}`;
@@ -97,7 +97,7 @@ async function executeQueriesOnNode(magentoCloud, projectId, environment, nodeId
             queries: queries.map(q => q.title)
         });
 
-        const { stdout, stderr } = await magentoCloud.executeCommand(sshCommand, apiToken); // Pass apiToken
+        const { stdout, stderr } = await magentoCloud.executeCommand(sshCommand, apiToken, userId); // Pass apiToken
 
         // Check if MySQL is not running
         if (stderr.includes('MySQL is not running on this node')) {
@@ -186,7 +186,7 @@ async function executeQueriesWithStrategy(projectId, environment, queries, apiTo
         await magentoCloud.validateExecutable();
 
         // Get all nodes first
-        const nodes = await getNodes(projectId, environment, apiToken); // Pass apiToken to getNodes
+        const nodes = await getNodes(projectId, environment, apiToken, userId); // Pass apiToken to getNodes
         if (!nodes || nodes.length === 0) {
             throw new Error('No nodes found in the environment');
         }
@@ -254,7 +254,8 @@ async function executeQueriesWithStrategy(projectId, environment, queries, apiTo
                     environment,
                     node.id,
                     multiNodeQueries,
-                    apiToken // Pass apiToken
+                    apiToken,
+                    userId
                 )
             );
 
@@ -307,12 +308,12 @@ async function runQueries(req, res) {
     }
 
     try {
-        const apiToken = await ApiTokenService.getApiToken(userId); // Get API token
+        const apiToken = req.session.decryptedApiToken;
         if (!apiToken) {
             return res.status(401).json({ error: 'API token not found for user' });
         }
 
-        const results = await executeQueriesWithStrategy(projectId, environment, queries, apiToken); // Pass apiToken
+        const results = await executeQueriesWithStrategy(projectId, environment, queries, apiToken, userId); // Pass apiToken
 
         res.json({
             projectId,
diff --git a/src/api/app/sshCommands.js b/src/api/app/sshCommands.js
index abf6f6c..bc1a5b4 100644
--- a/src/api/app/sshCommands.js
+++ b/src/api/app/sshCommands.js
@@ -64,13 +64,13 @@ function parseCommandOutput(output, commands) {
     return results;
 }
 
-async function executeWithRetry(magentoCloud, command, apiToken, options = { maxRetries: 3, delay: 1000 }) {
+async function executeWithRetry(magentoCloud, command, apiToken, userId, options = { maxRetries: 3, delay: 1000 }) {
     console.log('apiToken in sshCommands:executeWithRetry=====>', apiToken);
     let lastError;
 
     for (let attempt = 1; attempt <= options.maxRetries; attempt++) {
         try {
-            const result = await magentoCloud.executeCommand(command, apiToken); // Pass apiToken
+            const result = await magentoCloud.executeCommand(command, apiToken, userId); // Pass apiToken
             if (attempt > 1) {
                 logger.info('Command succeeded after retry', {
                     attempt,
@@ -109,7 +109,7 @@ async function executeWithRetry(magentoCloud, command, apiToken, options = { max
     throw lastError;
 }
 
-async function executeSSHCommandsOnNode(magentoCloud, projectId, environment, nodeId, commands, isSingleNode, apiToken) { // Add apiToken
+async function executeSSHCommandsOnNode(magentoCloud, projectId, environment, nodeId, commands, isSingleNode, apiToken, userId) { // Add apiToken
     console.log('apiToken in sshCommands:executeSSHCommandsOnNode=====>', apiToken);
     try {
         // Create the script content with all commands.
@@ -134,7 +134,8 @@ EOF`;
         const { stdout, stderr } = await executeWithRetry(
             magentoCloud,
             sshCommand,
-            apiToken, // Pass apiToken
+            apiToken,
+            userId,
             { maxRetries: 3, delay: 1000 }
         );
 
@@ -235,7 +236,7 @@ console.log('apiToken in sshCommands:runCommands=====>', apiToken);
         const magentoCloud = new MagentoCloudAdapter();
         await magentoCloud.validateExecutable();
 
-        const nodes = await getNodes(projectId, environment, apiToken); // Pass apiToken to getNodes
+        const nodes = await getNodes(projectId, environment, apiToken, userId); // Pass apiToken to getNodes
         const isSingleNode = !nodes || nodes.length <= 1;
 
         if (!nodes || nodes.length === 0) {
@@ -256,7 +257,8 @@ console.log('apiToken in sshCommands:runCommands=====>', apiToken);
                 isSingleNode ? null : nodes[0].id,
                 validCommands,
                 isSingleNode,
-                apiToken // Pass apiToken
+                apiToken,
+                userId
             );
 
             // Initialize results for all valid commands
@@ -279,7 +281,8 @@ console.log('apiToken in sshCommands:runCommands=====>', apiToken);
                         node.id,
                         allNodesCommands,
                         false,
-                        apiToken // Pass apiToken
+                        apiToken,
+                        userId
                     )
                 );
 
diff --git a/src/config/paths.js b/src/config/paths.js
index 844cbdb..fea399b 100644
--- a/src/config/paths.js
+++ b/src/config/paths.js
@@ -1,3 +1,4 @@
+// src/config/paths.js
 import { join, dirname } from 'path';
 import { fileURLToPath } from 'url';
 
diff --git a/src/services/rabbitmqAdminService.js b/src/services/rabbitmqAdminService.js
index d90b87d..a828d63 100644
--- a/src/services/rabbitmqAdminService.js
+++ b/src/services/rabbitmqAdminService.js
@@ -4,14 +4,16 @@ import { executeCommand } from '../api/app/magentoCloudDirectAccess.js';
 import MagentoCloudAdapter from '../adapters/magentoCloud.js';
 
 export class RabbitMQAdminService {
-    constructor(projectId, environment, apiToken) {
+    constructor(projectId, environment, apiToken, userId) {
         this.projectId = projectId;
         this.environment = environment;
         this.apiToken = apiToken;
+        this.userId = userId;
         this.magentoCloud = new MagentoCloudAdapter();
     }
 
     async executeCommand(command) {
+        console.log('userId from rabbitmqAdminService========================>', this.userId);
         try {
             // Extract RabbitMQ details from environment variable
             const rabbitmqHost = `$(echo $MAGENTO_CLOUD_RELATIONSHIPS | base64 -d | jq -r .rabbitmq[0].host)`;
@@ -33,7 +35,8 @@ export class RabbitMQAdminService {
                 this.magentoCloud,
                 sshCommand,
                 { projectId: this.projectId, environment: this.environment },
-                this.apiToken // Pass the apiToken
+                this.apiToken,
+                this.userId
             );
 
             if (status === 'ERROR') {
diff --git a/src/services/tunnelService.js b/src/services/tunnelService.js
index 3a9949e..40fbc31 100644
--- a/src/services/tunnelService.js
+++ b/src/services/tunnelService.js
@@ -134,12 +134,13 @@ class TunnelManager {
      * Retrieves the tunnel info from Magento Cloud. If no tunnel is found or
      * the tunnel is unhealthy, returns null.
      */
-    async getTunnelInfo(projectId, environment, apiToken) {
+    async getTunnelInfo(projectId, environment, apiToken, userId) {
+        console.log('userId in tunnelService:getTunnelInfo=====>', userId);
         const tunnelKey = `${projectId}-${environment}`;
         try {
             const { stdout } = await this.magentoCloud.executeCommand(
                 `tunnel:info -p ${projectId} -e ${environment} -y`,
-                apiToken
+                apiToken, userId
             );
             const tunnelInfo = this.parseTunnelInfo(stdout);
 
@@ -151,7 +152,7 @@ class TunnelManager {
                         environment
                     });
                     try {
-                        await this.magentoCloud.executeCommand('tunnel:close -y', apiToken);
+                        await this.magentoCloud.executeCommand('tunnel:close -y', apiToken, userId);
                     } catch (closeError) {
                         logger.debug('Error closing unhealthy tunnel', {
                             error: closeError.message
@@ -286,10 +287,10 @@ class TunnelManager {
      * Waits for the tunnel to open by spawning "tunnel:open" and parsing its output.
      * This resolves with the tunnel info once all services are reported as ready.
      */
-    async waitForTunnelOpen(projectId, environment, apiToken) {
+    async waitForTunnelOpen(projectId, environment, apiToken, userId) {
         return new Promise((resolve, reject) => {
             const command = `tunnel:open -p ${projectId} -e ${environment} -y`;
-            const { tunnelProcess } = this.magentoCloud.executeCommandStream(command, apiToken);
+            const { tunnelProcess } = this.magentoCloud.executeCommandStream(command, apiToken, userId);
 
             let servicesFound = {};
             let allServicesReady = false;
@@ -335,7 +336,8 @@ class TunnelManager {
                     try {
                         const { stdout } = await this.magentoCloud.executeCommand(
                             `tunnel:info -p ${projectId} -e ${environment} -y`,
-                            apiToken
+                            apiToken,
+                            userId
                         );
                         const tunnelInfo = this.parseTunnelInfo(stdout);
                         resolve(tunnelInfo);
@@ -366,7 +368,7 @@ class TunnelManager {
      */
     async openTunnel(projectId, environment, apiToken, userId, progressCallback) {
         console.log('apiToken in tunnelService:openTunnel=====>', apiToken);
-
+        console.log('userId in tunnelService:openTunnel=====>', userId);
         if (!userId) {
             throw new Error("userId is not provided");
         }
@@ -385,7 +387,7 @@ class TunnelManager {
             try {
                 // Quick check for existing tunnel
                 if (progressCallback) progressCallback('checking_existing_tunnel');
-                let tunnelInfo = await this.getTunnelInfo(projectId, environment, apiToken);
+                let tunnelInfo = await this.getTunnelInfo(projectId, environment, apiToken, userId);
                 if (tunnelInfo) {
                     if (progressCallback) progressCallback('tunnel_exists');
                     await this.incrementTunnelUsage(projectId, environment, userId);
@@ -403,7 +405,7 @@ class TunnelManager {
                     // Wait for the other process to finish opening
                     const startTime = Date.now();
                     while (Date.now() - startTime < LOCK_WAIT_TIMEOUT) {
-                        tunnelInfo = await this.getTunnelInfo(projectId, environment, apiToken);
+                        tunnelInfo = await this.getTunnelInfo(projectId, environment, apiToken, userId);
                         if (tunnelInfo) {
                             if (progressCallback) progressCallback('tunnel_opened_by_other_process');
                             await this.incrementTunnelUsage(projectId, environment, userId);
@@ -425,7 +427,7 @@ class TunnelManager {
                     });
 
                     if (progressCallback) progressCallback('opening_tunnel');
-                    const newTunnelInfo = await this.waitForTunnelOpen(projectId, environment, apiToken);
+                    const newTunnelInfo = await this.waitForTunnelOpen(projectId, environment, apiToken, userId);
 
                     // Verify the new tunnel is healthy
                     if (progressCallback) progressCallback('verifying_tunnel');
@@ -568,7 +570,7 @@ class TunnelManager {
             }
     
             // Attempt to retrieve the primary service
-            let tunnelInfo = await this.getTunnelInfo(projectId, environment, apiToken);
+            let tunnelInfo = await this.getTunnelInfo(projectId, environment, apiToken, userId);
     
             if (tunnelInfo && tunnelInfo[serviceName] && tunnelInfo[serviceName].length > 0) {
                 return { [serviceName]: tunnelInfo[serviceName] };
